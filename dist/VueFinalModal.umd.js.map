{"version":3,"file":"VueFinalModal.umd.js","sources":["../lib/utils/focusTrap.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/PluginCore.js","../lib/utils/errors.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\r\n\r\nconst FOCUSABLE_ELEMENTS_QUERY =\r\n  'button:not([disabled]), ' +\r\n  'select:not([disabled]), ' +\r\n  'a[href]:not([disabled]), ' +\r\n  'area[href]:not([disabled]), ' +\r\n  '[contentEditable=\"\"]:not([disabled]), ' +\r\n  '[contentEditable=\"true\"]:not([disabled]), ' +\r\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\r\n  'textarea:not([disabled]), ' +\r\n  'iframe:not([disabled]), ' +\r\n  'input:not([disabled]), ' +\r\n  'summary:not([disabled]), ' +\r\n  '[tabindex]:not([tabindex=\"-1\"])'\r\n\r\nconst isTabPressed = event => {\r\n  return event.key === 'Tab' || event.keyCode === 9\r\n}\r\n\r\nconst querySelectorAll = (element, selector) => {\r\n  return [...(element.querySelectorAll(selector) || [])]\r\n}\r\n\r\nconst queryFocusableElements = element => {\r\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\r\n}\r\n\r\nconst isFocused = element => {\r\n  return element == document.activeElement\r\n}\r\n\r\nconst isNothingFocused = () => {\r\n  return !document.activeElement\r\n}\r\n\r\nclass FocusTrap {\r\n  constructor() {\r\n    this.root = null\r\n    this.elements = []\r\n\r\n    this.onKeyDown = this.onKeyDown.bind(this)\r\n    this.enable = this.enable.bind(this)\r\n    this.disable = this.disable.bind(this)\r\n    this.firstElement = this.firstElement.bind(this)\r\n    this.lastElement = this.lastElement.bind(this)\r\n  }\r\n\r\n  lastElement() {\r\n    return this.elements[this.elements.length - 1] || null\r\n  }\r\n\r\n  firstElement() {\r\n    return this.elements[0] || null\r\n  }\r\n\r\n  onKeyDown(event) {\r\n    if (!isTabPressed(event)) {\r\n      return\r\n    }\r\n\r\n    // SHIFT + TAB\r\n    if (event.shiftKey) {\r\n      if (isFocused(this.firstElement())) {\r\n        this.lastElement().focus()\r\n        event.preventDefault()\r\n      }\r\n      return\r\n    }\r\n\r\n    // TAB\r\n    if (isNothingFocused() || isFocused(this.lastElement())) {\r\n      this.firstElement().focus()\r\n      event.preventDefault()\r\n      return\r\n    }\r\n  }\r\n\r\n  enabled() {\r\n    return !!this.root\r\n  }\r\n\r\n  enable(root) {\r\n    if (!root) {\r\n      return\r\n    }\r\n\r\n    this.root = root\r\n    this.elements = queryFocusableElements(this.root)\r\n\r\n    this.root.addEventListener('keydown', this.onKeyDown)\r\n  }\r\n\r\n  disable() {\r\n    this.root.removeEventListener('keydown', this.onKeyDown)\r\n    this.root = null\r\n  }\r\n}\r\n\r\nexport default FocusTrap\r\n","// stolen from body-scroll-lock\r\n\r\n// Older browsers don't support event options, feature detect it.\r\nlet hasPassiveEvents = false\r\nif (typeof window !== 'undefined') {\r\n  const passiveTestOptions = {\r\n    get passive() {\r\n      hasPassiveEvents = true\r\n      return undefined\r\n    }\r\n  }\r\n  window.addEventListener('testPassive', null, passiveTestOptions)\r\n  window.removeEventListener('testPassive', null, passiveTestOptions)\r\n}\r\n\r\nconst isIosDevice =\r\n  typeof window !== 'undefined' &&\r\n  window.navigator &&\r\n  window.navigator.platform &&\r\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\r\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\r\n\r\nlet locks = []\r\nlet documentListenerAdded = false\r\nlet clientY = 0\r\nlet initialClientY = -1\r\nlet previousBodyOverflowSetting\r\nlet previousBodyPaddingRight\r\n\r\nconst hasScrollbar = el => {\r\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\r\n\r\n  const style = window.getComputedStyle(el)\r\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\r\n}\r\n\r\nconst shouldScroll = (el, delta) => {\r\n  if (el.scrollTop === 0 && delta < 0) return false\r\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\r\n  return true\r\n}\r\n\r\nconst composedPath = el => {\r\n  const path = []\r\n  while (el) {\r\n    path.push(el)\r\n    if (el.classList.contains('vfm')) return path\r\n    el = el.parentElement\r\n  }\r\n  return path\r\n}\r\n\r\nconst hasAnyScrollableEl = (el, delta) => {\r\n  let hasAnyScrollableEl = false\r\n  const path = composedPath(el)\r\n  path.forEach(el => {\r\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\r\n      hasAnyScrollableEl = true\r\n    }\r\n  })\r\n  return hasAnyScrollableEl\r\n}\r\n\r\n// returns true if `el` should be allowed to receive touchmove events.\r\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\r\n\r\nconst preventDefault = rawEvent => {\r\n  const e = rawEvent || window.event\r\n\r\n  // For the case whereby consumers adds a touchmove event listener to document.\r\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\r\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\r\n  // the touchmove event on document will break.\r\n  if (allowTouchMove(e.target)) {\r\n    return true\r\n  }\r\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\r\n  if (e.touches.length > 1) return true\r\n\r\n  if (e.preventDefault) e.preventDefault()\r\n\r\n  return false\r\n}\r\n\r\nconst setOverflowHidden = options => {\r\n  // If previousBodyPaddingRight is already set, don't set it again.\r\n  if (previousBodyPaddingRight === undefined) {\r\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\r\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\r\n\r\n    if (reserveScrollBarGap && scrollBarGap > 0) {\r\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\r\n      previousBodyPaddingRight = document.body.style.paddingRight\r\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\r\n    }\r\n  }\r\n  // If previousBodyOverflowSetting is already set, don't set it again.\r\n  if (previousBodyOverflowSetting === undefined) {\r\n    previousBodyOverflowSetting = document.body.style.overflow\r\n    document.body.style.overflow = 'hidden'\r\n  }\r\n}\r\n\r\nconst restoreOverflowSetting = () => {\r\n  if (previousBodyPaddingRight !== undefined) {\r\n    document.body.style.paddingRight = previousBodyPaddingRight\r\n\r\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\r\n    // can be set again.\r\n    previousBodyPaddingRight = undefined\r\n  }\r\n\r\n  if (previousBodyOverflowSetting !== undefined) {\r\n    document.body.style.overflow = previousBodyOverflowSetting\r\n\r\n    // Restore previousBodyOverflowSetting to undefined\r\n    // so setOverflowHidden knows it can be set again.\r\n    previousBodyOverflowSetting = undefined\r\n  }\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\r\nconst isTargetElementTotallyScrolled = targetElement =>\r\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\r\n\r\nconst handleScroll = (event, targetElement) => {\r\n  clientY = event.targetTouches[0].clientY - initialClientY\r\n\r\n  if (allowTouchMove(event.target)) {\r\n    return false\r\n  }\r\n\r\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\r\n    // element is at the top of its scroll.\r\n    return preventDefault(event)\r\n  }\r\n\r\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\r\n    // element is at the bottom of its scroll.\r\n    return preventDefault(event)\r\n  }\r\n\r\n  event.stopPropagation()\r\n  return true\r\n}\r\n\r\nexport const disableBodyScroll = (targetElement, options) => {\r\n  // targetElement must be provided\r\n  if (!targetElement) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(\r\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\r\n    )\r\n    return\r\n  }\r\n\r\n  // disableBodyScroll must not have been called on this targetElement before\r\n  if (locks.some(lock => lock.targetElement === targetElement)) {\r\n    return\r\n  }\r\n\r\n  const lock = {\r\n    targetElement,\r\n    options: options || {}\r\n  }\r\n\r\n  locks = [...locks, lock]\r\n\r\n  if (isIosDevice) {\r\n    targetElement.ontouchstart = event => {\r\n      if (event.targetTouches.length === 1) {\r\n        // detect single touch.\r\n        initialClientY = event.targetTouches[0].clientY\r\n      }\r\n    }\r\n    targetElement.ontouchmove = event => {\r\n      if (event.targetTouches.length === 1) {\r\n        // detect single touch.\r\n        handleScroll(event, targetElement)\r\n      }\r\n    }\r\n\r\n    if (!documentListenerAdded) {\r\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\r\n      documentListenerAdded = true\r\n    }\r\n  } else {\r\n    setOverflowHidden(options)\r\n  }\r\n}\r\n\r\nexport const enableBodyScroll = targetElement => {\r\n  if (!targetElement) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(\r\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\r\n    )\r\n    return\r\n  }\r\n\r\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\r\n\r\n  if (isIosDevice) {\r\n    targetElement.ontouchstart = null\r\n    targetElement.ontouchmove = null\r\n\r\n    if (documentListenerAdded && locks.length === 0) {\r\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\r\n      documentListenerAdded = false\r\n    }\r\n  } else if (!locks.length) {\r\n    restoreOverflowSetting()\r\n  }\r\n}\r\n","<template>\r\n  <div\r\n    v-if=\"ssr || visible\"\r\n    v-show=\"!ssr || visible\"\r\n    :style=\"bindStyle\"\r\n    class=\"vfm vfm--inset\"\r\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\r\n    @keydown.esc=\"onEsc\"\r\n  >\r\n    <transition\r\n      :name=\"overlayTransition\"\r\n      @before-enter=\"beforeOverlayEnter\"\r\n      @after-enter=\"afterOverlayEnter\"\r\n      @before-leave=\"beforeOverlayLeave\"\r\n      @after-leave=\"afterOverlayLeave\"\r\n    >\r\n      <div\r\n        v-show=\"!hideOverlay && visibility.overlay\"\r\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\r\n        :class=\"overlayClass\"\r\n        :style=\"overlayStyle\"\r\n      ></div>\r\n    </transition>\r\n    <transition\r\n      :name=\"transition\"\r\n      @before-enter=\"beforeModalEnter\"\r\n      @after-enter=\"afterModalEnter\"\r\n      @before-leave=\"beforeModalLeave\"\r\n      @after-leave=\"afterModalLeave\"\r\n    >\r\n      <div\r\n        v-show=\"visibility.modal\"\r\n        ref=\"vfmContainer\"\r\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\r\n        :class=\"classes\"\r\n        :style=\"styles\"\r\n        :aria-expanded=\"visibility.modal.toString()\"\r\n        role=\"dialog\"\r\n        aria-modal=\"true\"\r\n        tabindex=\"-1\"\r\n        @click.self=\"onClickContainer\"\r\n      >\r\n        <div class=\"vfm__content\" :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\" :style=\"contentStyle\">\r\n          <slot v-bind:params=\"params\" />\r\n        </div>\r\n      </div>\r\n    </transition>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport FocusTrap from './utils/focusTrap.js'\r\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\r\n\r\nconst TransitionState = {\r\n  Enter: 'enter',\r\n  Entering: 'entering',\r\n  Leave: 'leave',\r\n  Leaving: 'leavng'\r\n}\r\n\r\nfunction validateAttachTarget(val) {\r\n  const type = typeof val\r\n\r\n  if (type === 'boolean' || type === 'string') return true\r\n\r\n  return val.nodeType === Node.ELEMENT_NODE\r\n}\r\n\r\nconst STYLE_PROP = {\r\n  type: [String, Object, Array],\r\n  default: ''\r\n}\r\n\r\nexport default {\r\n  props: {\r\n    name: { type: String, default: null },\r\n    value: { type: Boolean, default: false },\r\n    ssr: { type: Boolean, default: true },\r\n    classes: STYLE_PROP,\r\n    overlayClass: STYLE_PROP,\r\n    contentClass: STYLE_PROP,\r\n    styles: STYLE_PROP,\r\n    overlayStyle: STYLE_PROP,\r\n    contentStyle: STYLE_PROP,\r\n    lockScroll: { type: Boolean, default: true },\r\n    hideOverlay: { type: Boolean, default: false },\r\n    clickToClose: { type: Boolean, default: true },\r\n    escToClose: { type: Boolean, default: false },\r\n    preventClick: { type: Boolean, default: false },\r\n    attach: { type: null, default: false, validator: validateAttachTarget },\r\n    transition: { type: String, default: 'vfm' },\r\n    overlayTransition: { type: String, default: 'vfm' },\r\n    zIndexAuto: { type: Boolean, default: true },\r\n    zIndexBase: { type: [String, Number], default: 1000 },\r\n    zIndex: { type: [Boolean, String, Number], default: false },\r\n    focusRetain: { type: Boolean, default: true },\r\n    focusTrap: { type: Boolean, default: false }\r\n  },\r\n  data: () => ({\r\n    modalStackIndex: null,\r\n    visible: false,\r\n    visibility: {\r\n      modal: false,\r\n      overlay: false\r\n    },\r\n    overlayTransitionState: null,\r\n    modalTransitionState: null,\r\n    stopEvent: false,\r\n    params: {}\r\n  }),\r\n  computed: {\r\n    api() {\r\n      return this[this.$_options.key]\r\n    },\r\n    isComponentReadyToBeDestroyed() {\r\n      return (\r\n        (this.hideOverlay || this.overlayTransitionState === TransitionState.Leave) &&\r\n        this.modalTransitionState === TransitionState.Leave\r\n      )\r\n    },\r\n    calculateZIndex() {\r\n      if (this.zIndex === false) {\r\n        if (this.zIndexAuto) {\r\n          return +this.zIndexBase + 2 * (this.modalStackIndex || 0)\r\n        } else {\r\n          return false\r\n        }\r\n      } else {\r\n        return this.zIndex\r\n      }\r\n    },\r\n    bindStyle() {\r\n      return {\r\n        ...(this.calculateZIndex !== false && { zIndex: this.calculateZIndex })\r\n      }\r\n    }\r\n  },\r\n  watch: {\r\n    value(value) {\r\n      if (this.stopEvent) {\r\n        this.stopEvent = false\r\n        return\r\n      }\r\n      this.mounted()\r\n      if (!value) {\r\n        if (this.emitEvent('before-close', true)) {\r\n          return\r\n        }\r\n        this.close()\r\n      }\r\n    },\r\n    lockScroll: 'handleLockScroll',\r\n    hideOverlay(value) {\r\n      if (this.value && !value) {\r\n        this.visibility.overlay = true\r\n      }\r\n    },\r\n    attach: 'mounted',\r\n    isComponentReadyToBeDestroyed(isReady) {\r\n      if (isReady) {\r\n        this.visible = false\r\n      }\r\n    }\r\n  },\r\n  created() {\r\n    this.api.modals.push(this)\r\n  },\r\n  mounted() {\r\n    this.$focusTrap = new FocusTrap()\r\n    this.mounted()\r\n  },\r\n  beforeDestroy() {\r\n    this.close()\r\n    this.lockScroll && this.$refs.vfmContainer && enableBodyScroll(this.$refs.vfmContainer)\r\n    this?.$el?.remove()\r\n\r\n    let index = this.api.modals.findIndex(vm => vm === this)\r\n    this.api.modals.splice(index, 1)\r\n  },\r\n  methods: {\r\n    mounted() {\r\n      if (this.value) {\r\n        if (this.emitEvent('before-open', false)) {\r\n          return\r\n        }\r\n        let target = this.getAttachElement()\r\n        if (target || this.attach === false) {\r\n          this.attach !== false && target.appendChild(this.$el)\r\n\r\n          let index = this.api.openedModals.findIndex(vm => vm === this)\r\n          if (index !== -1) {\r\n            // if this is already exist in modalStack, delete it\r\n            this.api.openedModals.splice(index, 1)\r\n          }\r\n          this.api.openedModals.push(this)\r\n\r\n          this.modalStackIndex = this.api.openedModals.length - 1\r\n\r\n          this.handleLockScroll()\r\n          this.api.openedModals\r\n            .filter(vm => vm !== this)\r\n            .forEach((vm, index) => {\r\n              if (vm.getAttachElement() === target) {\r\n                // if vm and this have the same attach element\r\n                vm.modalStackIndex = index\r\n                vm.visibility.overlay = false\r\n              }\r\n            })\r\n\r\n          this.visible = true\r\n          this.$nextTick(() => {\r\n            this.startTransitionEnter()\r\n          })\r\n        } else if (target !== false) {\r\n          console.warn('Unable to locate target '.concat(this.attach))\r\n        }\r\n      }\r\n    },\r\n    close() {\r\n      let index = this.api.openedModals.findIndex(vm => vm === this)\r\n      if (index !== -1) {\r\n        // remove this in modalStack\r\n        this.api.openedModals.splice(index, 1)\r\n      }\r\n      if (this.api.openedModals.length > 0) {\r\n        // If there are still nested modals opened\r\n        const $_vm = this.api.openedModals[this.api.openedModals.length - 1]\r\n        if ($_vm.focusRetain || $_vm.focusTrap) {\r\n          $_vm.$refs.vfmContainer.focus()\r\n        }\r\n        !$_vm.hideOverlay && ($_vm.visibility.overlay = true)\r\n      }\r\n      this.startTransitionLeave()\r\n    },\r\n    startTransitionEnter() {\r\n      this.visibility.overlay = true\r\n      this.visibility.modal = true\r\n    },\r\n    startTransitionLeave() {\r\n      this.visibility.overlay = false\r\n      this.visibility.modal = false\r\n    },\r\n    handleLockScroll() {\r\n      if (this.value) {\r\n        this.$nextTick(() => {\r\n          if (this.lockScroll) {\r\n            disableBodyScroll(this.$refs.vfmContainer, {\r\n              reserveScrollBarGap: true\r\n            })\r\n          } else {\r\n            enableBodyScroll(this.$refs.vfmContainer)\r\n          }\r\n        })\r\n      }\r\n    },\r\n    getAttachElement() {\r\n      let target\r\n      if (this.attach === false) {\r\n        target = false\r\n      } else if (typeof this.attach === 'string') {\r\n        // CSS selector\r\n        if (window) {\r\n          target = window.document.querySelector(this.attach)\r\n        } else {\r\n          target = false\r\n        }\r\n      } else {\r\n        // DOM Element\r\n        target = this.attach\r\n      }\r\n      return target\r\n    },\r\n    beforeOverlayEnter() {\r\n      this.overlayTransitionState = TransitionState.Entering\r\n    },\r\n    afterOverlayEnter() {\r\n      this.overlayTransitionState = TransitionState.Enter\r\n    },\r\n    beforeOverlayLeave() {\r\n      this.overlayTransitionState = TransitionState.Leaving\r\n    },\r\n    afterOverlayLeave() {\r\n      this.overlayTransitionState = TransitionState.Leave\r\n    },\r\n    beforeModalEnter() {\r\n      this.modalTransitionState = TransitionState.Entering\r\n    },\r\n    afterModalEnter() {\r\n      this.modalTransitionState = TransitionState.Enter\r\n      if (this.focusRetain || this.focusTrap) {\r\n        this.$refs.vfmContainer.focus()\r\n      }\r\n      if (this.focusTrap) {\r\n        this.$focusTrap.enable(this.$refs.vfmContainer)\r\n      }\r\n      this.$emit('opened', this.createModalEvent({ type: 'opened' }))\r\n    },\r\n    beforeModalLeave() {\r\n      this.modalTransitionState = TransitionState.Leaving\r\n\r\n      if (this.$focusTrap.enabled()) {\r\n        this.$focusTrap.disable()\r\n      }\r\n    },\r\n    afterModalLeave() {\r\n      this.modalTransitionState = TransitionState.Leave\r\n      this.modalStackIndex = null\r\n      this.lockScroll && enableBodyScroll(this.$refs.vfmContainer)\r\n\r\n      let stopEvent = false\r\n      const event = this.createModalEvent({\r\n        type: 'closed',\r\n        stop() {\r\n          stopEvent = true\r\n        }\r\n      })\r\n      this.$emit('closed', event)\r\n      if (stopEvent) return\r\n      this.params = {}\r\n    },\r\n    onClickContainer() {\r\n      this.$emit('click-outside', this.createModalEvent({ type: 'click-outside' }))\r\n      this.clickToClose && this.$emit('input', false)\r\n    },\r\n    onEsc() {\r\n      if (this.visible && this.escToClose) {\r\n        this.$emit('input', false)\r\n      }\r\n    },\r\n    createModalEvent(eventProps = {}) {\r\n      return {\r\n        ref: this,\r\n        ...eventProps\r\n      }\r\n    },\r\n    emitEvent(eventType, value) {\r\n      let stopEvent = false\r\n      const event = this.createModalEvent({\r\n        type: eventType,\r\n        stop() {\r\n          stopEvent = true\r\n        }\r\n      })\r\n      this.$emit(eventType, event)\r\n      if (stopEvent) {\r\n        this.stopEvent = true\r\n        this.$emit('input', value)\r\n        return true\r\n      }\r\n      return false\r\n    },\r\n    toggle(show, params) {\r\n      const value = typeof show === 'boolean' ? show : !this.value\r\n      if (value && arguments.length === 2) {\r\n        this.params = params\r\n      }\r\n      this.$emit('input', value)\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"css\" scoped>\r\n.vfm--fixed {\r\n  position: fixed;\r\n}\r\n.vfm--absolute {\r\n  position: absolute;\r\n}\r\n.vfm--inset {\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n}\r\n.vfm--overlay {\r\n  background-color: rgba(0, 0, 0, 0.5);\r\n}\r\n.vfm--prevent-none {\r\n  pointer-events: none;\r\n}\r\n.vfm--prevent-auto {\r\n  pointer-events: auto;\r\n}\r\n.vfm--outline-none:focus {\r\n  outline: none;\r\n}\r\n.vfm-enter-active,\r\n.vfm-leave-active {\r\n  transition: opacity 0.2s;\r\n}\r\n.vfm-enter,\r\n.vfm-leave-to {\r\n  opacity: 0;\r\n}\r\n</style>\r\n","import VueFinalModal from './VueFinalModal.vue'\r\nimport ModalsContainer from './ModalsContainer.vue'\r\n\r\nfunction assignOptions(component, options) {\r\n  const _component = { ...component }\r\n  Object.assign(_component.props, {\r\n    $_options: { type: Object, default: () => options }\r\n  })\r\n  return _component\r\n}\r\n\r\nfunction createVfm(Vue, options) {\r\n  let vfm\r\n\r\n  return function() {\r\n    vfm = {\r\n      show(modal, ...args) {\r\n        switch (typeof modal) {\r\n          case 'string':\r\n            this.toggle(modal, true, ...args)\r\n            break\r\n          case 'object':\r\n            {\r\n              const defaultModal = {\r\n                value: true,\r\n                id: Symbol('dynamicModal'),\r\n                component: options.componentName,\r\n                bind: {},\r\n                slots: {},\r\n                on: {},\r\n                params: args[0]\r\n              }\r\n              this.dynamicModals.push(Object.assign(defaultModal, modal))\r\n            }\r\n            break\r\n        }\r\n      },\r\n      hide(...names) {\r\n        this.toggle(names, false)\r\n      },\r\n      hideAll() {\r\n        for (let i = this.openedModals.length - 1; i >= 0; i--) {\r\n          this.openedModals[i].$emit('input', false)\r\n        }\r\n      },\r\n      toggle(name, ...args) {\r\n        const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\r\n        modals.forEach(modal => modal.toggle(...args))\r\n      },\r\n      get(...names) {\r\n        return this.modals.filter(modal => names.includes(modal.name))\r\n      },\r\n      dynamicModals: [],\r\n      openedModals: [],\r\n      modals: []\r\n    }\r\n    return Vue.observable(vfm)\r\n  }\r\n}\r\n\r\nexport function bindPrototype(Vue, options) {\r\n  const vfm = createVfm(Vue, options)()\r\n  Object.defineProperty(Vue.prototype, options.key, {\r\n    get() {\r\n      return vfm\r\n    }\r\n  })\r\n}\r\n\r\nexport function registModal(Vue, options) {\r\n  Vue.component(options.componentName, assignOptions(VueFinalModal, options))\r\n}\r\nexport function registContainer(Vue, options) {\r\n  Vue.component(options.dynamicContainerName, assignOptions(ModalsContainer, options))\r\n}\r\n","export const DUPLICATE_PLUGIN_COMPONENT =\r\n  '[vue-final-modal] Duplicate registration API key and componentName of VueFinalModal.'\r\n\r\nexport const DUPLICATE_COMPONENT = '[vue-final-modal] Duplicate registration componentName of VueFinalModal.'\r\n\r\nexport const DUPLICATE_DYNAMIC_CONTAINER =\r\n  '[vue-final-modal] Duplicate registration dynamicContainerName of ModalsContainer.'\r\n","import { bindPrototype, registModal, registContainer } from './PluginCore'\r\nimport { DUPLICATE_PLUGIN_COMPONENT, DUPLICATE_COMPONENT, DUPLICATE_DYNAMIC_CONTAINER } from './utils/errors'\r\n\r\nconst defaultOptions = {\r\n  componentName: 'VueFinalModal',\r\n  dynamicContainerName: 'ModalsContainer',\r\n  key: '$vfm'\r\n}\r\n\r\nconst Plugin = () => ({\r\n  install(Vue, options) {\r\n    const _options = Object.assign({}, defaultOptions, options)\r\n    const isDuplicateKey = Vue.prototype[_options.key]\r\n    const isDuplicateComponent = Vue.options.components[_options.componentName]\r\n    const isDuplicateDynamicContainer = Vue.options.components[_options.dynamicContainerName]\r\n\r\n    if (isDuplicateComponent || isDuplicateDynamicContainer) {\r\n      if (typeof window !== 'undefined') {\r\n        if (isDuplicateKey) {\r\n          console.error(DUPLICATE_PLUGIN_COMPONENT)\r\n        }\r\n        if (isDuplicateComponent) {\r\n          console.error(DUPLICATE_COMPONENT)\r\n        }\r\n        if (isDuplicateDynamicContainer) {\r\n          console.error(DUPLICATE_DYNAMIC_CONTAINER)\r\n        }\r\n      }\r\n    } else {\r\n      if (!isDuplicateKey) {\r\n        bindPrototype(Vue, _options)\r\n      }\r\n      registModal(Vue, _options)\r\n      registContainer(Vue, _options)\r\n    }\r\n  }\r\n})\r\n\r\nexport default Plugin\r\n"],"names":["queryFocusableElements","element","selector","querySelectorAll","isFocused","document","activeElement","FocusTrap","root","elements","onKeyDown","this","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","addEventListener","removeEventListener","hasPassiveEvents","window","passiveTestOptions","previousBodyOverflowSetting","previousBodyPaddingRight","isIosDevice","navigator","platform","test","maxTouchPoints","locks","documentListenerAdded","clientY","initialClientY","hasAnyScrollableEl","el","delta","path","push","classList","contains","parentElement","composedPath","forEach","nodeType","Node","ELEMENT_NODE","style","getComputedStyle","includes","overflowY","scrollHeight","clientHeight","hasScrollbar","scrollTop","shouldScroll","allowTouchMove","some","rawEvent","e","target","touches","disableBodyScroll","targetElement","options","lock","ontouchstart","targetTouches","ontouchmove","isTargetElementTotallyScrolled","stopPropagation","handleScroll","passive","undefined","reserveScrollBarGap","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","body","getPropertyValue","paddingRight","overflow","setOverflowHidden","console","error","enableBodyScroll","filter","assignOptions","component","_component","Object","assign","props","$_options","type","default","bindPrototype","Vue","vfm","show","modal","args","toggle","defaultModal","value","id","Symbol","componentName","slots","on","params","dynamicModals","hide","names","hideAll","i","openedModals","$emit","name","Array","isArray","get","modals","observable","createVfm","defineProperty","prototype","defaultOptions","dynamicContainerName","install","_options","isDuplicateKey","isDuplicateComponent","components","isDuplicateDynamicContainer","VueFinalModal","registModal","ModalsContainer","registContainer"],"mappings":"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"}